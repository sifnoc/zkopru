<<<<<<< HEAD
// import fs from 'fs'
import BN from 'bn.js'
import { toWei } from 'web3-utils'

import { Fp } from '@zkopru/babyjubjub'
import { DB } from '@zkopru/database'
import { UtxoStatus, Utxo, Sum } from '@zkopru/transaction'
import { HDWallet, ZkAccount } from '@zkopru/account'
import { logger, sleep } from '@zkopru/utils'
import { ZkWalletAccount, ZkWalletAccountConfig } from '@zkopru/zk-wizard'
import { TestTxBuilder } from './testbuilder'
import { jsonToZkTx, logAll } from './generator-utils'
=======
import BN from 'bn.js'
import { toWei } from 'web3-utils'

import { DB } from '@zkopru/database'
import { TxBuilder, UtxoStatus, Utxo, RawTx } from '@zkopru/transaction'
import { HDWallet, ZkAccount } from '@zkopru/account'
import { logger, sleep } from '@zkopru/utils'
import { F } from '~babyjubjub/fp'
import { ZkWallet } from '~zk-wizard'
import {
  ZkWalletAccount,
  ZkWalletAccountConfig,
} from '~zk-wizard/zk-wallet-account'
import { logAll } from './generator-utils'
>>>>>>> refactor: create generator class for eth transfer on layer2

// TODO : extends to other type of assets
export type noteAmount = { eth: string; fee: string }

export interface GeneratorConfig {
  db: DB
  hdWallet: HDWallet
  account: ZkAccount
  noteAmount?: noteAmount
<<<<<<< HEAD
  weiPrice?: string
  ID?: number
}

//* * Only ETH transafer zkTx generator as 1 inflow 2 outflows */
export class TransferGenerator extends ZkWalletAccount {
  ID: number

  activating: boolean

=======
  maxInflowNote?: number // Can be extend to 4
  weiPrice?: string
}

export class TransferGenerator extends ZkWalletAccount {
  private hdWallet: HDWallet

  wallet: ZkWallet

  activating: boolean

  txCount: number

>>>>>>> refactor: create generator class for eth transfer on layer2
  noteAmount: noteAmount

  unspentUTXO: Utxo[]

<<<<<<< HEAD
  onQueueUTXOSalt: number[]

  weiPrice: string

  worker: Worker | undefined

  lastSalt: Fp

  usePreZkTx: boolean

  constructor(config: ZkWalletAccountConfig & GeneratorConfig) {
    super(config)
    this.ID = config.ID ?? Math.floor(Math.random() * 10000) // TODO : It seems only need in docker environment
    this.activating = false
=======
  onQueueUTXOSalt: F[]

  maxInflowNote: number // Can be extend up to 4, over 4 will be error.

  weiPrice: string

  constructor(config: ZkWalletAccountConfig & GeneratorConfig) {
    super(config)
    this.activating = false
    this.txCount = 0

    this.hdWallet = config.hdWallet

    // TODO: More base generator can be added erc20 or erc721
    this.wallet = new ZkWallet({
      db: config.db,
      wallet: this.hdWallet,
      node: this.node,
      account: config.account,
      accounts: [config.account],
      erc20: [],
      erc721: [],
      snarkKeyPath: config.snarkKeyPath,
    })
>>>>>>> refactor: create generator class for eth transfer on layer2
    this.noteAmount = config.noteAmount ?? {
      eth: toWei('0.1'),
      fee: toWei('0.01'),
    }
    this.unspentUTXO = []
    this.onQueueUTXOSalt = []
<<<<<<< HEAD
    this.weiPrice = config.weiPrice ?? toWei('2000', 'gwei')
    this.usePreZkTx = false

    /**  
     * Starting with Ether Note generated by deposit tx, It has 1 as salt
    
    the salt will be using a sequence for mass transaction in layer 2 as testing
     
         2 - 4 ...
       /   \  
     1       5 ...
       \     
         3 - 6 ...
           \
             7 ...
    */
    this.lastSalt = Fp.from(1)
=======
    this.maxInflowNote = config.maxInflowNote ?? 2 // If set 1 It will increasing notes
    this.weiPrice = config.weiPrice ?? toWei('2000', 'gwei')
>>>>>>> refactor: create generator class for eth transfer on layer2
  }

  async startGenerator() {
    if (!this.node.isRunning()) {
      this.node.start()
    }

<<<<<<< HEAD
    // let tx: RawTx

    logger.info(`sending deposit Tx with salt ${this.lastSalt.toString()}`)
    try {
      const result = await this.depositEther(
        toWei('50'),
        this.noteAmount.fee,
        this.account?.zkAddress,
        this.lastSalt,
      )
      if (!result) {
        throw new Error(' Deposit Transaction Failed!')
      } else {
        this.activating = true
      }
    } catch (err) {
      logger.error(err)
    }
    // let currentUtxo

    while (this.activating) {
      this.unspentUTXO = await this.getUtxos(this.account, UtxoStatus.UNSPENT)

      // Deposit if does not exist unspent utxo in this wallet
      if (this.unspentUTXO.length === 0) {
        logger.info('No Spendable Utxo, wait until available')
=======
    this.activating = true

    let tx: RawTx
    let sendableUtxo: Utxo[]
    let stagedUtxo

    while (this.activating) {
      this.unspentUTXO = await this.wallet.getUtxos(
        this.account,
        UtxoStatus.UNSPENT,
      )

      // Dequeue necessary?

      // Deposit if does not exist unspent utxo in this wallet
      if (this.unspentUTXO.length === 0) {
        logger.info('No Spendable Utxo, send Deposit Tx')
        try {
          const result = await this.wallet.depositEther(
            this.noteAmount.eth,
            this.noteAmount.fee,
            this.account?.zkAddress,
          )
          if (!result) {
            throw new Error('[Wallet] Deposit Transaction Failed!')
          }
        } catch (err) {
          logger.error(err)
        }
>>>>>>> refactor: create generator class for eth transfer on layer2
        await sleep(10000)
        continue
      }

      // generate transfer Tx...
      // All transaction are self transaction with same amount, only unique things is salt.
<<<<<<< HEAD
      const sendableUtxo: Utxo[] = []
      let stagedUtxo

      // TODO : refactor this
      for (const utxo of this.unspentUTXO) {
        stagedUtxo = utxo
        for (let i = 0; i < this.onQueueUTXOSalt.length; i++) {
          if (this.onQueueUTXOSalt[i] === utxo.salt.toNumber()) {
            stagedUtxo = undefined
            break
          }
        }
        if (stagedUtxo != undefined) {
          sendableUtxo.push(stagedUtxo) // last utxo always in
        }
        if (sendableUtxo.length >= 1) {
=======
      sendableUtxo = []

      for (const utxo of this.unspentUTXO) {
        stagedUtxo = utxo
        for (let i = 0; i < this.onQueueUTXOSalt.length; i++) {
          if (this.onQueueUTXOSalt[i] == utxo.salt) {
            stagedUtxo = null
            break
          }
        }
        if (stagedUtxo) {
          sendableUtxo.push(stagedUtxo) // last utxo always in
        }
        // No need to be find all unspent utxo
        if (sendableUtxo.length > this.maxInflowNote) {
          logger.info(`sendable UTXO salts are ${logAll(sendableUtxo)}`)
>>>>>>> refactor: create generator class for eth transfer on layer2
          break
        }
      }

<<<<<<< HEAD
      // TODO : Create Tx then goto queue
      if (sendableUtxo.length > 0 && this.usePreZkTx) {
        logger.info(
          `sendable UTXO salts are ${logAll(
            sendableUtxo.map(utxo => utxo.salt.toString()),
          )}`,
        )
        logger.info(`${logAll(sendableUtxo)}`)
        // currentUtxo = await this.db.findMany('Utxo', { where: {} })
        // logger.info(`All UTXO 3>> ${logAll(currentUtxo)}`)

        const { tx, zkTx } = jsonToZkTx(
          `./packages/generator/zktx/${sendableUtxo[0].salt}.json`,
        )

        try {
          // TODO : private method in ZkWalletAccount class
          tx.outflow.forEach(async outflow => {
            logger.info(
              `try to create utxo ${outflow
                .hash()
                .toUint256()
                .toString()}`,
            )
            await this.db.create('Utxo', {
              hash: outflow
                .hash()
                .toUint256()
                .toString(),
              owner: outflow.owner.toString(),
              salt: outflow.salt.toUint256().toString(),
              eth: outflow
                .eth()
                .toUint256()
                .toString(),
              tokenAddr: outflow
                .tokenAddr()
                .toAddress()
                .toString(),
              erc20Amount: outflow
                .erc20Amount()
                .toUint256()
                .toString(),
              nft: outflow
                .nft()
                .toUint256()
                .toString(),
              status: UtxoStatus.NON_INCLUDED,
            })
          })
          this.lockUtxos(tx.inflow)
          await this.sendLayer2Tx(zkTx)
          this.onQueueUTXOSalt.push(sendableUtxo[0].salt.toNumber())
        } catch (err) {
          logger.error(err)
        }
      } else if (sendableUtxo.length > 0) {
        const testTxBuilder = new TestTxBuilder(this.account?.zkAddress!)
        const tx = testTxBuilder
          .provide(...sendableUtxo)
          .weiPerByte(this.weiPrice)
          .sendEther({
            eth: Sum.from(sendableUtxo).eth.div(new BN(2)),
            salt: sendableUtxo[0].salt.muln(2),
=======
      if (sendableUtxo) {
        const txBuilder = TxBuilder.from(this.account?.zkAddress!)
        tx = txBuilder
          .provide(...sendableUtxo)
          .weiPerByte(this.weiPrice)
          .sendEther({
            eth: new BN(this.noteAmount.eth).div(new BN(100)),
>>>>>>> refactor: create generator class for eth transfer on layer2
            to: this.account?.zkAddress!,
          })
          .build()

<<<<<<< HEAD
        const parsedZkTx = {
          inflow: tx.inflow.map(flow => {
            return {
              hash: flow.hash().toString(),
              salt: flow.salt.toString(10),
              eth: flow.eth().toString(10),
            }
          }),
          outflow: tx.outflow.map(flow => {
            return {
              hash: flow.hash().toString(),
              salt: flow.salt.toString(10),
              eth: flow.eth().toString(10),
            }
          }),
        }
        // fs.writeFileSync(`${tx.inflow[0].salt.toString(10)}.json`, JSON.stringify(parsedZkTx))
        logger.info(`Generated zkTx ${logAll(parsedZkTx)}`)
        try {
          await this.sendTx({
=======
        try {
          await this.wallet.sendTx({
>>>>>>> refactor: create generator class for eth transfer on layer2
            tx,
            from: this.account,
            encryptTo: this.account?.zkAddress,
          })
          sendableUtxo.forEach(utxo => {
<<<<<<< HEAD
            this.onQueueUTXOSalt.push(utxo.salt.toNumber())
          })
        } catch (err) {
          logger.error(err)
          // }
        }
      } else {
        logger.info(`Waiting...`)
      }
      await sleep(1000)
=======
            this.onQueueUTXOSalt.push(utxo.salt)
          })
          this.txCount += 1
        } catch (err) {
          logger.error(err)
        }
      }
>>>>>>> refactor: create generator class for eth transfer on layer2
    }
  }

  stopGenerator() {
    this.activating = false
  }
}
