// import fs from 'fs'
import BN from 'bn.js'
import { toWei } from 'web3-utils'
import { Queue, Worker, Job } from 'bullmq'
import fetch from 'node-fetch'

import { Fp } from '@zkopru/babyjubjub'
import { UtxoStatus, Utxo, RawTx, ZkTx } from '@zkopru/transaction'
import { HDWallet } from '@zkopru/account'
import { logger, sleep } from '@zkopru/utils'
import { ZkWalletAccount, ZkWalletAccountConfig } from '@zkopru/zk-wizard'
import { TestTxBuilder } from './testbuilder'
import { fileToZkTx, jsonToZkTx, logAll } from './generator-utils'

export interface GeneratorConfig {
  hdWallet: HDWallet
  weiPrice?: string
  ID?: number
  redis?: { host: string; port: number }
  preZkTxPath?: string
}

//* * Only ETH transafer zkTx generator as 1 inflow 2 outflows */
export class TransferGenerator extends ZkWalletAccount {
  ID: number

  isActive: boolean

  usedUtxoSalt: Set<number>

  weiPrice: string

  lastSalt: Fp

  usePreZkTx: boolean

  preZkTxPath: string

  queue: Queue

  queueConnection: any

  constructor(config: ZkWalletAccountConfig & GeneratorConfig) {
    super(config)
    this.ID = config.ID ?? Math.floor(Math.random() * 10000) // TODO : It seems only need in docker environment
    this.isActive = false
    this.preZkTxPath = config.preZkTxPath ?? `../zktx/${this.ID}`
    this.usedUtxoSalt = new Set([])
    this.weiPrice = config.weiPrice ?? toWei('2000', 'gwei')
    this.usePreZkTx = false

    /**  
     * Starting with Ether Note generated by deposit tx, It has 1 as salt
    
    the salt will be using a sequence for mass transaction in layer 2 for testing
     
         2 - 4 ...
       /   \  
     1       5 ...
       \     
         3 - 6 ...
           \
             7 ...
    */
    this.lastSalt = Fp.from(1)

    this.queueConnection = {
      connection: {
        host: config.redis?.host ?? 'localhost',
        port: config.redis?.port ?? 6379,
      },
    }

    this.queue = new Queue('mainTxQueue', this.queueConnection)
  }

  async sendPreZkTx(tx: RawTx, zkTx: ZkTx) {
    try {
      // TODO : check private method in ZkWalletAccount class
      tx.outflow.forEach(async outflow => {
        logger.info(
          `try to create utxo ${outflow
            .hash()
            .toUint256()
            .toString()}`,
        )
        await this.db.create('Utxo', {
          hash: outflow
            .hash()
            .toUint256()
            .toString(),
          owner: outflow.owner.toString(),
          salt: outflow.salt.toUint256().toString(),
          eth: outflow
            .eth()
            .toUint256()
            .toString(),
          tokenAddr: outflow
            .tokenAddr()
            .toAddress()
            .toString(),
          erc20Amount: outflow
            .erc20Amount()
            .toUint256()
            .toString(),
          nft: outflow
            .nft()
            .toUint256()
            .toString(),
          status: UtxoStatus.NON_INCLUDED,
        })
      })
      this.lockUtxos(tx.inflow)
      await this.sendLayer2Tx(zkTx)
    } catch (err) {
      logger.error(err)
    }
  }

  async startWorker() {
    logger.info(`Worker started`)
    const worker = new Worker(
      `wallet${this.ID}`,
      async (job: Job) => {
        // logger.info(`job.data >> ${logAll(job.data)}`)
        const { rawTx, rawZkTx } = job.data
        const { tx, zkTx } = jsonToZkTx(rawTx, rawZkTx)
        const response = await this.sendLayer2Tx(zkTx)
        if (response.status !== 200) {
          await this.unlockUtxos(tx.inflow)
          throw Error(await response.text())
        }
        // const spendableUtxo = new Utxo(this.account?.zkAddress!, Fp.from(rawTx.salt), rawTx.asset, UtxoStatus.NON_INCLUDED)
        // logger.info(`generated tx from .. zkAddress ${logAll(this.account?.zkAddress)}`)
        // const testTxBuilder = new TestTxBuilder(this.account?.zkAddress!)
        // logger.info(`Instanced txbuilder >> sum eth : ${spendableUtxo.asset.eth.div(new BN(2))}`)
        // const tx = testTxBuilder
        //   .provide(...[spendableUtxo])
        //   .weiPerByte(this.weiPrice)
        //   .sendEther({
        //     eth: spendableUtxo.asset.eth.div(new BN(2)), // TODO: eth amount include a half of fee
        //     salt: spendableUtxo.salt.muln(2),
        //     to: this.account?.zkAddress!,
        //   })
        //   .build()

        // logger.info(`Built tx >> ${logAll(tx)}`)
        // try {
        //   await this.sendTx({
        //     tx,
        //     from: this.account,
        //     encryptTo: this.account?.zkAddress,
        //   })
        // } catch (err) {
        //   logger.error(err)
        // }
      },
      this.queueConnection,
    )

    worker.on('completed', (job: Job) => {
      logger.info(`Worker job ${logAll(job.id)} completed`)
    })
  }

  async startGenerator() {
    if (!this.node.isRunning()) {
      this.node.start()
    }

    try {
      const result = await this.depositEther(
        toWei('50'),
        toWei('0.01'),
        this.account?.zkAddress,
        Fp.from(1),
      )
      if (!result) {
        throw new Error(' Deposit Transaction Failed!')
      } else {
        logger.info(`Deposit Tx sent`)
      }
    } catch (err) {
      logger.error(err)
    }

    while (!this.isActive) {
      await sleep(1000)
      const stagedDeposit = await this.node.layer1.upstream.methods
        .stagedDeposits()
        .call()

      if (+stagedDeposit.merged === 0) {
        this.isActive = true
        fetch(`http://organizer:8080/register`, {
          method: 'post',
          body: JSON.stringify({
            ID: this.ID,
            address: this.account?.ethAddress,
          }),
        })
        logger.info(`Deposit Tx is processed`)
      }
    }

    this.startWorker()

    // TODO : before start loop, check and get list of pre-generated zktx on ID
    // const preZkTxFiles = fs.readdirSync(this.preZkTxPath)
    // logger.info(`current pre-generated zktx files ${preZkTxFiles.length}`)

    while (this.isActive) {
      const onQueue = await this.queue.getJobCounts('wait', 'active', 'delayed')
      if (onQueue.wait + onQueue.active + onQueue.delayed >= 1000) {
        await sleep(1000)
        continue
      }
      const unspentUTXO = await this.getUtxos(this.account, UtxoStatus.UNSPENT)

      if (unspentUTXO.length === 0) {
        logger.info('No Spendable Utxo, wait until available')
        await sleep(5000)
        continue
      }

      // All transaction are self transaction with same amount, only unique things is salt.
      let sendableUtxo: Utxo | undefined

      for (const utxo of unspentUTXO) {
        let isUsedUtxo = false
        if (this.usedUtxoSalt.has(utxo.salt.toNumber())) {
          isUsedUtxo = true
        }

        if (!isUsedUtxo) {
          sendableUtxo = utxo
          break
        }
      }

      // TODO : Create Tx then goto queue
      // TODO : not using flag, then goto check how many pre-generated utxo are available..
      if (sendableUtxo && this.usePreZkTx) {
        logger.info(`found sendable utxo with used Pre-zktx`)
        const { tx, zkTx } = fileToZkTx(
          `./packages/generator/zktx/${this.ID}/${sendableUtxo.salt}.json`,
        )

        try {
          // TODO : check private method in ZkWalletAccount class
          tx.outflow.forEach(async outflow => {
            await this.db.create('Utxo', {
              hash: outflow
                .hash()
                .toUint256()
                .toString(),
              owner: outflow.owner.toString(),
              salt: outflow.salt.toUint256().toString(),
              eth: outflow
                .eth()
                .toUint256()
                .toString(),
              tokenAddr: outflow
                .tokenAddr()
                .toAddress()
                .toString(),
              erc20Amount: outflow
                .erc20Amount()
                .toUint256()
                .toString(),
              nft: outflow
                .nft()
                .toUint256()
                .toString(),
              status: UtxoStatus.NON_INCLUDED,
            })
          })
          this.lockUtxos(tx.inflow)
          await this.sendLayer2Tx(zkTx)
          this.usedUtxoSalt.add(sendableUtxo.salt.toNumber())
        } catch (err) {
          logger.error(err)
        }
      } else if (sendableUtxo && !this.usePreZkTx) {
        logger.info(`found sendable utxo without pre`)
        const testTxBuilder = new TestTxBuilder(this.account?.zkAddress!)
        const tx = testTxBuilder
          .provide(sendableUtxo)
          .weiPerByte(this.weiPrice)
          .sendEther({
            eth: sendableUtxo.asset.eth.div(new BN(2)), // TODO: eth amount include a half of fee
            salt: sendableUtxo.salt.muln(2),
            to: this.account?.zkAddress!,
          })
          .build()

        const parsedZkTx = {
          inflow: tx.inflow.map(flow => {
            return {
              hash: flow.hash().toString(),
              salt: flow.salt.toString(10),
              eth: flow.eth().toString(10),
            }
          }),
          outflow: tx.outflow.map(flow => {
            return {
              hash: flow.hash().toString(),
              salt: flow.salt.toString(10),
              eth: flow.eth().toString(10),
            }
          }),
        }
        logger.info(`Created ZkTx : ${logAll(parsedZkTx)}`)
        try {
          const zkTx = await this.shieldTx({
            tx,
            from: this.account,
            encryptTo: this.account?.zkAddress,
          })
          // await this.sendTx({
          //   tx,
          //   from: this.account,
          //   encryptTo: this.account?.zkAddress,
          // })
          this.queue.add(`wallet${this.ID}`, { rawTx: tx, rawZkTx: zkTx })
          this.usedUtxoSalt.add(sendableUtxo.salt.toNumber())
        } catch (err) {
          logger.error(err)
        }
      } else {
        logger.debug(`No available utxo for now wait 1 sec`)
      }
      await sleep(1000)
    }
  }

  stopGenerator() {
    this.isActive = false
  }
}
